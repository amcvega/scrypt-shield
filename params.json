{"name":"Shield","body":"# Shield\r\n\r\n_n. A solid piece of metal code used to protect your application._\r\n\r\n## Why another authentication library?\r\n\r\n1. Because most of the other libraries are too huge.\r\n2. Extending other libraries is a pain.\r\n3. Writing code is fun :-)\r\n\r\n## What shield is\r\n\r\n1. Simple (~ 110 lines of Ruby code)\r\n2. Doesn't get in the way\r\n3. Treats you like a grown up\r\n\r\n## What shield is not\r\n\r\n- is _not_ a ready-made end-to-end authentication solution.\r\n- is _not_ biased towards any kind of ORM.\r\n\r\n## Understanding Shield in 15 minutes\r\n\r\n### Shield::Model\r\n\r\n`Shield::Model` is a very basic protocol for doing authentication\r\nagainst your model. It doesn't assume a lot, apart from the following:\r\n\r\n1. You will implement `User.fetch` which receives the login string.\r\n2. You have an attribute `crypted_password` which is able to store\r\n   up to __192__ characters.\r\n\r\nAnd that's it.\r\n\r\nIn order to implement the model protocol, you start by\r\nincluding `Shield::Model`.\r\n\r\n```ruby\r\nclass User < Struct.new(:email, :crypted_password)\r\n  include Shield::Model\r\n\r\n  def self.fetch(email)\r\n    user = new(email)\r\n    user.password = \"pass1234\"\r\n\r\n    return user\r\n  end\r\nend\r\n```\r\n\r\nBy including `Shield::Model`, you get all the general methods needed\r\nin order to do authentication.\r\n\r\n1. You get `User.authenticate` which receives the login string and\r\n   password as the two parameters.\r\n2. You get `User#password=` which automatically converts the clear text\r\n   password into a hashed form and assigns it into `#crypted_password`.\r\n\r\n```ruby\r\nu = User.new(\"foo@bar.com\")\r\n\r\n# A password accessor has been added which manages `crypted_password`.\r\nu.password = \"pass1234\"\r\n\r\nShield::Password.check(\"pass1234\", u.crypted_password)\r\n# => true\r\n\r\n# Since we've hard coded all passwords to pass1234\r\n# we're able to authenticate properly.\r\nnil == User.authenticate(\"foo@bar.com\", \"pass1234\")\r\n# => false\r\n\r\n# If we try a different password on the other hand,\r\n# we get `nil`.\r\nnil == User.authenicate(\"foo@bar.com\", \"wrong\")\r\n# => true\r\n```\r\n\r\nShield includes tests for [ohm][ohm] and [sequel][sequel] and makes sure\r\nthat each release works with the latest respective versions.\r\n\r\nTake a look at [test/ohm.rb][ohm-test] and [test/sequel.rb][sequel-test]\r\nto learn more.\r\n\r\n### Logging in with an email and username?\r\n\r\nIf your requirements dictate that you need to be able to support logging\r\nin using either username or email, then you can simply extend `User.fetch`\r\na bit by doing:\r\n\r\n```ruby\r\n# in Sequel\r\nclass User < Sequel::Model\r\n  def self.fetch(identifier)\r\n    filter(email: identifier).first || filter(username: identifier).first\r\n  end\r\nend\r\n\r\n# in Ohm\r\nclass User < Ohm::Model\r\n  attribute :email\r\n  attribute :username\r\n\r\n  unique :email\r\n  unique :username\r\n\r\n  def self.fetch(identifier)\r\n    with(:email, identifier) || with(:username, identifier)\r\n  end\r\nend\r\n```\r\n\r\nIf you want to allow case-insensitive logins for some reason, you can\r\nsimply normalize the values to their lowercase form.\r\n\r\n[ohm]: http://ohm.keyvalue.org\r\n[sequel]: http://sequel.rubyforge.org\r\n\r\n[ohm-test]: https://github.com/cyx/shield/blob/master/test/ohm.rb\r\n[sequel-test]: https://github.com/cyx/shield/blob/master/test/sequel.rb\r\n\r\n### Shield::Helpers\r\n\r\nAs the name suggests, `Shield::Helpers` is out there to aid you a bit,\r\nbut this time it aids you in the context of your Rack application.\r\n\r\n`Shield::Helpers` assumes only the following:\r\n\r\n1. You have included in your application a Session handler,\r\n   (e.g. Rack::Session::Cookie)\r\n2. You have an `env` method which returns the environment hash as\r\n   was passed in Rack.\r\n\r\n**Note:** As of this writing, Sinatra, Cuba & Rails adhere to having an `env`\r\nmethod in the handler / controller context. Shield also ships with tests for\r\nboth Cuba and Sinatra.\r\n\r\n```ruby\r\nrequire \"sinatra\"\r\n\r\n# Satisifies assumption number 1 above.\r\nuse Rack::Session::Cookie\r\n\r\n# Mixes `Shield::Helpers` into your routes context.\r\nhelpers Shield::Helpers\r\n\r\nget \"/private\" do\r\n  error(401) unless authenticated(User)\r\n\r\n  \"Private\"\r\nend\r\n\r\nget \"/login\" do\r\n  erb :login\r\nend\r\n\r\npost \"/login\" do\r\n  if login(User, params[:login], params[:password], params[:remember_me])\r\n    redirect(params[:return] || \"/\")\r\n  else\r\n    redirect \"/login\"\r\n  end\r\nend\r\n\r\nget \"/logout\" do\r\n  logout(User)\r\n  redirect \"/\"\r\nend\r\n\r\n__END__\r\n\r\n@@ login\r\n<h1>Login</h1>\r\n\r\n<form action='/login' method='post'>\r\n<input type='text' name='login' placeholder='Email'>\r\n<input type='password' name='password' placeholder='Password'>\r\n<input type='submit' name='proceed' value='Login'>\r\n```\r\n\r\n**Note for the reader**: The redirect to `params[:return]` in the example\r\nis vulnerable to URL hijacking. You can whitelist redirectable urls, or\r\nsimply make sure the URL matches the pattern `/\\A[\\/a-z0-9\\-]+\\z/i`.\r\n\r\n### Shield::Middleware\r\n\r\nIf you have a keen eye you might have noticed that instead of redirecting\r\naway to the login URL in the example above, we instead chose to do a\r\n`401 Unauthorized`. In strict HTTP Status code terms, this is the proper\r\napproach. The redirection is simply the user experience pattern that has\r\nemerged in web applications.\r\n\r\nBut don't despair! If you want to do redirects simply add\r\n`Shield::Middleware` to your middleware stack like so:\r\n\r\n```ruby\r\n# taken from example above\r\nuse Shield::Middleware, \"/login\"\r\nuse Rack::Session::Cookie\r\n\r\n# rest of code follows here\r\n# ...\r\n```\r\n\r\nNow when your application responds with a `401`, `Shield::Middleware`\r\nwill be responsible for doing the redirect to `/login`.\r\n\r\nIf you try and do a `curl --head http://localhost:4567/private` with\r\n`Shield::Middleware`, you'll get a response similar to the following:\r\n\r\n```\r\nHTTP/1.1 302 Found\r\nLocation: http://localhost:4567/login?return=%2Fprivate\r\nContent-Type: text/html\r\n```\r\n\r\nNotice that it specifies `/private` as the return URL.\r\n\r\n## Jump starting your way.\r\n\r\nFor people interested in using Cuba, Ohm, Shield and Bootstrap we've\r\ncreated a starting point that includes **Login**, **Signup** and\r\n**Forgot Password** functionality.\r\n\r\nHead on over to the [cuba-app][cuba-app] repository if you want\r\nto know more.\r\n\r\n[cuba-app]: http://github.com/citrusbyte/cuba-app\r\n","tagline":"Authentication protocol for use in your routing and model context","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}